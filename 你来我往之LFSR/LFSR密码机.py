import numpy as npimport randomimport copydef Create_Matrix(list, dimension):#这个函数的作用是根据密码多项式（形如：[[1,0,1]]）的列表，广播为一个完整的转移矩阵    for i in range(0, dimension - 1):        row = []        for j in range(0, dimension):            if j == i:                row.append(1)            else:                row.append(0)        list.append(row)    matrix = np.array(list)    return matrixdef display(vector):#这个函数的作用是展示一个矩阵    for row in vector:        for item in row:            print(item, " ", end='')    print("")def Create_Crypto_and_Initial(dimension):#这个函数的作用是创建寄存器初始值和密码多项式    crypto = [[]]    initial = [[]]    for i in range(0, dimension):        val = random.randint(0, 1)        crypto[0].append(val)    for i in range(0, dimension):        val = random.randint(0, 1)        initial[0].append(val)    return crypto, initialdef Create_Stream(matrix, LFSR, count):#产生密码流    with open("Stream.txt", mode='w') as file:        for i in range(1, count + 1):            LFSR = np.dot(matrix, LFSR)            LFSR[0][0] = LFSR[0][0] % 2            for row in LFSR:                for item in row:                    file.write(str(item)+' ')            file.write('\n')def row_add(row_1, row_2):#功能在于把矩阵的两行加起来（模二），然后返回这一新行    val = row_1 + row_2    for i in range(0, len(val)):        val[i] = val[i] % 2    return valdef row_exchange(matrix, index_1, index_2):#功能在于交换矩阵的两行    temp = copy.copy(matrix[index_1])    matrix[index_1] = matrix[index_2]    matrix[index_2] = tempdef search_pivot(matrix, start_index, pivot_index):#从第start_index行开始，找一个有主元（也就是第pivot_index个元素是1）的行，返回其下标    for index in range(start_index, len(matrix)):        if matrix[index][pivot_index] == 1:            return index    return -1def rref(matrix):    row, column = matrix.shape    size = matrix.shape[0] if matrix.shape[0]<matrix.shape[1] else matrix.shape[1]    for i in range(0, size):#一列一列来，先找主元，用主元消掉这一列其他所有1        if matrix[i][i] == 0:#没有主元,换一个有主元的行上来            idx = search_pivot(matrix=matrix, start_index=i, pivot_index=i)#从这一行往下的行找主元，有解的情况下，必然能找到主元。            row_exchange(matrix=matrix, index_1=i, index_2=idx)#这一行与有主元的那一行交换，以构成阶梯型。        for j in range(0, row):#消掉这一列所有的1            if not j == i:                if matrix[j][i] == 1:#如果是1，通过行相加，消掉1                    matrix[j] = row_add(matrix[j], matrix[i])        #print('第',i,'次消元结果为')        #print(matrix)        print(i)def decrypto():#根据同目录下txt文件存储的比特流，进行解密。    temp = []    with open('Stream.txt', mode='r') as file:        for line in file.readlines():            line = line.split()            val = [int(i) for i in line]            temp.append(val)#把字符串形式的玩意全转换成int型    for i in range(0, len(temp) - 1):        temp[i].append(temp[i+1][0])#等于是说，把矩阵增了一列    print('读取完毕')    temp.pop()#然后扔掉最后一行，因为这行没东西可以让他增加一列    matrix = np.array(temp)    rref(matrix)    print('rref完毕')    with open('result.txt', mode='w') as rst:        for row in matrix:            for item in row:                rst.write(str(item)+' ')            rst.write(' \n')    print('打印完毕')def encrypto(dimension, count): #生成密码、生成转移矩阵、生成比特流    #dimension #寄存器的bit数    crypto, initial = Create_Crypto_and_Initial(dimension)    #crypto = [[1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1]]    print('crypto: ', crypto)    print('initial: ', initial)    matrix = Create_Matrix(crypto, dimension)    print(matrix)    LFSR = np.array(initial).T    Create_Stream(matrix=matrix, LFSR=LFSR, count=count)if __name__ == '__main__':    print('1:加密 2:解密 3:关闭')    while True:        try:            choice = int(input())            if choice == 1:                dimension = int(input('输入LFSR bit数'))                count = int(input('输入产生的状态数'))                encrypto(dimension=dimension, count=count)            elif choice == 2:                decrypto()            else:                exit(1)        except ValueError:            print('输入有误')